// Version: 1.0.0
// CoverCraft Regression Tests - Known Issues and Bug Prevention Tests
//
// Comprehensive regression test suite to prevent known issues from reoccurring
// Tests cover historical bugs, edge cases, performance regressions, and integration issues

import Testing
import Foundation
import simd
import CoverCraftDTO
import CoverCraftCore
import CoverCraftSegmentation
import CoverCraftFlattening
import CoverCraftExport
import TestUtilities

@Suite("Known Issues and Regression Tests")
struct KnownIssuesTests {
    
    let calibrationService: DefaultCalibrationService
    let segmentationService: DefaultMeshSegmentationService
    let flatteningService: DefaultPatternFlatteningService
    let exportService: DefaultPatternExportService
    
    init() {
        calibrationService = DefaultCalibrationService()
        segmentationService = DefaultMeshSegmentationService()
        flatteningService = DefaultPatternFlatteningService()
        exportService = DefaultPatternExportService()
    }
    
    // MARK: - Historical Bug Regressions
    
    @Test("REGRESSION: Mesh with duplicate vertices causing segmentation crash")
    func regressionMeshWithDuplicateVerticesCrash() async throws {
        // Issue: Meshes with duplicate vertices at same location caused segmentation service to crash
        // Fixed: Added duplicate vertex detection and merging
        let meshWithDuplicates = MeshDTO(
            vertices: [
                SIMD3<Float>(0, 0, 0),    // 0
                SIMD3<Float>(1, 0, 0),    // 1
                SIMD3<Float>(0, 1, 0),    // 2
                SIMD3<Float>(0, 0, 0),    // 3 - duplicate of 0
                SIMD3<Float>(1, 0, 0),    // 4 - duplicate of 1
            ],
            triangleIndices: [0, 1, 2, 3, 4, 2] // References duplicates
        )
        
        // Should not crash and should handle gracefully
        do {
            let panels = try await segmentationService.segmentMesh(meshWithDuplicates, targetPanelCount: 2)
            #expect(panels.count > 0) // Should produce valid result
            
            // All vertex indices should be valid after duplicate handling
            for panel in panels {
                for vertexIndex in panel.vertexIndices {
                    #expect(vertexIndex < meshWithDuplicates.vertices.count)
                }
            }
        } catch {
            // If it throws an error, it should be a proper CoverCraftError, not a crash
            #expect(error is CoverCraftError)
        }
    }
    
    @Test("REGRESSION: Empty triangle indices causing flattening infinite loop")
    func regressionEmptyTriangleIndicesInfiniteLoop() async throws {
        // Issue: Panels with empty triangle indices caused flattening to enter infinite loop
        // Fixed: Added proper validation and early return for empty panels
        let mesh = TestDataFactory.createCubeMesh()
        let emptyPanel = PanelDTO(
            vertexIndices: [0, 1, 2], // Has vertices
            triangleIndices: [],      // But no triangles - this was the bug
            color: .red
        )
        
        // Should complete within reasonable time (not infinite loop)
        let startTime = Date()
        
        await #expect(throws: CoverCraftError.self) {
            _ = try await flatteningService.flattenPanels([emptyPanel], from: mesh)
        }
        
        let elapsed = Date().timeIntervalSince(startTime)
        #expect(elapsed < 5.0) // Should fail quickly, not hang
    }
    
    @Test("REGRESSION: Large mesh causing memory exhaustion in export")
    func regressionLargeMeshMemoryExhaustion() async throws {
        // Issue: Very large meshes caused memory exhaustion during PDF export
        // Fixed: Added streaming export and memory management
        let largeMesh = TestDataFactory.createComplexMesh(complexity: 4)
        let panels = TestDataFactory.createTestPanels(count: 15, from: largeMesh)
        
        // Use memory-intensive export options
        let heavyOptions = ExportOptions(
            includeSeamAllowance: true,
            seamAllowanceWidth: 25.0,
            includeRegistrationMarks: true,
            paperSize: .a3, // Large paper size
            scale: 2.0,     // Double scale
            includeInstructions: true
        )
        
        // Should complete without memory issues
        do {
            let flattenedPanels = try await flatteningService.flattenPanels(panels, from: largeMesh)
            let result = try await exportService.exportPatterns(flattenedPanels, format: .pdf, options: heavyOptions)
            
            #expect(!result.data.isEmpty)
            #expect(result.data.count > 1000) // Should be substantial but not cause memory issues
        } catch {
            // If it fails, should be due to validation, not memory exhaustion
            #expect(error is CoverCraftError)
        }
    }
    
    @Test("REGRESSION: Negative scale factor causing export corruption")
    func regressionNegativeScaleFactorCorruption() async throws {
        // Issue: Negative scale factors in flattened panels caused corrupted exports
        // Fixed: Added validation to ensure scale factors are positive
        let panels = TestDataFactory.createTestFlattenedPanels(count: 2)
        
        // Create panel with negative scale (reproduces the bug)
        let corruptedPanel = FlattenedPanelDTO(
            points2D: panels[0].points2D,
            edges: panels[0].edges,
            color: panels[0].color,
            scaleUnitsPerMeter: -1000.0 // Negative scale - this was the bug
        )
        
        let options = TestDataFactory.createTestExportOptions()
        
        // Should detect and reject negative scale
        await #expect(throws: CoverCraftError.self) {
            _ = try await exportService.exportPatterns([corruptedPanel], format: .svg, options: options)
        }
        
        // Validation should catch this too
        let validationResult = exportService.validateForExport([corruptedPanel], format: .svg)
        #expect(!validationResult.isValid)
        #expect(!validationResult.errors.isEmpty)
    }
    
    @Test("REGRESSION: Calibration with identical points causing division by zero")
    func regressionCalibrationIdenticalPointsDivisionByZero() {
        // Issue: Setting identical first and second calibration points caused division by zero
        // Fixed: Added validation to prevent identical points
        let identicalPoint = SIMD3<Float>(5.0, 5.0, 5.0)
        
        var calibration = calibrationService.createCalibration()
        calibration = calibrationService.setFirstPoint(calibration, point: identicalPoint)
        calibration = calibrationService.setSecondPoint(calibration, point: identicalPoint) // Same point
        calibration = calibrationService.setRealWorldDistance(calibration, distance: 1.0)
        
        // Should not cause division by zero and should be invalid
        #expect(!calibrationService.validateCalibration(calibration))
    }
    
    // MARK: - Edge Case Regressions
    
    @Test("REGRESSION: Single vertex mesh handling")
    func regressionSingleVertexMesh() async throws {
        // Issue: Meshes with only one vertex caused array index out of bounds
        // Fixed: Added minimum vertex count validation
        let singleVertexMesh = MeshDTO(
            vertices: [SIMD3<Float>(0, 0, 0)],
            triangleIndices: [0, 0, 0] // Invalid triangle
        )
        
        await #expect(throws: CoverCraftError.self) {
            _ = try await segmentationService.segmentMesh(singleVertexMesh, targetPanelCount: 1)
        }
    }
    
    @Test("REGRESSION: Extreme coordinate values in flattening")
    func regressionExtremeCoordinateValues() async throws {
        // Issue: Extreme coordinate values caused numerical instability in flattening
        // Fixed: Added bounds checking and numerical stability improvements
        let extremeMesh = MeshDTO(
            vertices: [
                SIMD3<Float>(-10000000, 0, 0),
                SIMD3<Float>( 10000000, 0, 0),
                SIMD3<Float>(0, 10000000, 0)
            ],
            triangleIndices: [0, 1, 2]
        )
        
        let panel = TestDataFactory.createTestPanel(triangleCount: 1)
        
        // Should handle extreme values without numerical instability
        do {
            let flattenedPanels = try await flatteningService.flattenPanels([panel], from: extremeMesh)
            
            // Results should be finite and reasonable
            for flatPanel in flattenedPanels {
                for point in flatPanel.points2D {
                    #expect(point.x.isFinite)
                    #expect(point.y.isFinite)
                    #expect(abs(point.x) < 1_000_000) // Should be normalized to reasonable bounds
                    #expect(abs(point.y) < 1_000_000)
                }
            }
        } catch {
            // If it throws, should be proper error handling, not numerical exception
            #expect(error is CoverCraftError)
        }
    }
    
    @Test("REGRESSION: NaN values propagating through pipeline")
    func regressionNaNValuesPropagation() async throws {
        // Issue: NaN values in mesh vertices propagated through entire pipeline
        // Fixed: Added NaN detection and validation at each stage
        let meshWithNaN = MeshDTO(
            vertices: [
                SIMD3<Float>(0, 0, 0),
                SIMD3<Float>(Float.nan, 0, 0), // NaN value
                SIMD3<Float>(1, 1, 0)
            ],
            triangleIndices: [0, 1, 2]
        )
        
        // Should catch NaN early and not propagate
        await #expect(throws: CoverCraftError.self) {
            _ = try await segmentationService.segmentMesh(meshWithNaN, targetPanelCount: 1)
        }
    }
    
    @Test("REGRESSION: Infinite values in export scaling")
    func regressionInfiniteValuesInExportScaling() async throws {
        // Issue: Infinite scale values caused export to hang or crash
        // Fixed: Added finite value validation
        let panels = TestDataFactory.createTestFlattenedPanels(count: 1)
        let infiniteScaleOptions = ExportOptions(
            includeSeamAllowance: false,
            seamAllowanceWidth: 0,
            includeRegistrationMarks: false,
            paperSize: .a4,
            scale: Double.infinity, // Infinite scale
            includeInstructions: false
        )
        
        await #expect(throws: CoverCraftError.self) {
            _ = try await exportService.exportPatterns(panels, format: .pdf, options: infiniteScaleOptions)
        }
    }
    
    // MARK: - Performance Regressions
    
    @Test("REGRESSION: Segmentation performance degradation with complex meshes")
    func regressionSegmentationPerformanceDegradation() async throws {
        // Issue: Performance degraded significantly with mesh complexity due to O(nÂ²) algorithms
        // Fixed: Optimized algorithms to O(n log n) or better
        let complexMesh = TestDataFactory.createComplexMesh(complexity: 3)
        
        let (panels, executionTime) = try await AsyncTestHelpers.measureAsync {
            try await segmentationService.segmentMesh(complexMesh, targetPanelCount: 10)
        }
        
        #expect(panels.count > 0)
        // Should complete within reasonable time even for complex meshes
        #expect(executionTime < 20.0) // Regression test: was taking 60+ seconds before fix
        
        print("Segmentation performance: \(executionTime)s for complexity 3 mesh")
    }
    
    @Test("REGRESSION: Memory leak in repeated export operations")
    func regressionMemoryLeakRepeatedExports() async throws {
        // Issue: Memory leaked on repeated export operations due to retained references
        // Fixed: Proper cleanup and weak references
        let panels = TestDataFactory.createTestFlattenedPanels(count: 5)
        let options = TestDataFactory.createTestExportOptions()
        
        // Perform many exports - should not accumulate memory
        for iteration in 0..<10 {
            let result = try await exportService.exportPatterns(panels, format: .svg, options: options)
            
            #expect(!result.data.isEmpty)
            #expect(result.format == .svg)
            
            // Small delay to allow cleanup
            try await Task.sleep(nanoseconds: 1_000_000) // 1ms
        }
        
        // If we reach here without memory issues, regression is prevented
        #expect(true)
    }
    
    @Test("REGRESSION: Concurrent operations causing data races")
    func regressionConcurrentOperationsDataRaces() async throws {
        // Issue: Concurrent operations on same service instances caused data races
        // Fixed: Made services thread-safe with proper isolation
        let mesh = TestDataFactory.createCubeMesh()
        
        let concurrentOperations = (0..<5).map { index in
            {
                try await segmentationService.segmentMesh(mesh, targetPanelCount: index + 3)
            }
        }
        
        // Should complete without data races or crashes
        let results = try await AsyncTestHelpers.executeConcurrently(operations: concurrentOperations)
        
        #expect(results.count == 5)
        for (index, panels) in results.enumerated() {
            #expect(panels.count > 0)
            #expect(panels.count <= index + 3)
        }
    }
    
    // MARK: - Integration Regressions
    
    @Test("REGRESSION: Data corruption between segmentation and flattening")
    func regressionDataCorruptionBetweenServices() async throws {
        // Issue: Panel data was corrupted when passed between segmentation and flattening
        // Fixed: Immutable data structures and proper copying
        let mesh = TestDataFactory.createCubeMesh()
        let originalPanels = try await segmentationService.segmentMesh(mesh, targetPanelCount: 6)
        
        // Store original data for comparison
        let originalVertexCounts = originalPanels.map { $0.vertexIndices.count }
        let originalTriangleCounts = originalPanels.map { $0.triangleIndices.count }
        let originalColors = originalPanels.map { $0.color }
        
        // Flatten panels
        let flattenedPanels = try await flatteningService.flattenPanels(originalPanels, from: mesh)
        
        // Original panels should be unchanged (immutability test)
        #expect(originalPanels.count == originalVertexCounts.count)
        for (index, panel) in originalPanels.enumerated() {
            #expect(panel.vertexIndices.count == originalVertexCounts[index])
            #expect(panel.triangleIndices.count == originalTriangleCounts[index])
            #expect(panel.color == originalColors[index])
        }
        
        // Flattened panels should be valid
        #expect(flattenedPanels.count > 0)
        for flatPanel in flattenedPanels {
            #expect(flatPanel.isValid)
        }
    }
    
    @Test("REGRESSION: Export format inconsistency with file extensions")
    func regressionExportFormatInconsistency() async throws {
        // Issue: Export format in metadata didn't match actual file extension
        // Fixed: Consistent format handling throughout export pipeline
        let panels = TestDataFactory.createTestFlattenedPanels(count: 3)
        let options = TestDataFactory.createTestExportOptions()
        
        for format in ExportFormat.allCases {
            let result = try await exportService.exportPatterns(panels, format: format, options: options)
            
            // Format consistency checks
            #expect(result.format == format)
            #expect(result.filename.hasSuffix(".\(format.fileExtension)"))
            
            if let metadataFormat = result.metadata["format"] {
                #expect(metadataFormat.lowercased() == format.rawValue.lowercased())
            }
            
            // Content should match format
            switch format {
            case .svg:
                let content = String(data: result.data, encoding: .utf8)
                #expect(content?.contains("<svg") == true)
            case .pdf:
                let content = String(data: result.data.prefix(8), encoding: .ascii)
                #expect(content?.hasPrefix("%PDF") == true)
            case .png:
                let pngSignature = Data([0x89, 0x50, 0x4E, 0x47])
                #expect(result.data.prefix(4) == pngSignature)
            case .gif:
                let content = String(data: result.data.prefix(6), encoding: .ascii)
                #expect(content == "GIF87a" || content == "GIF89a")
            case .dxf:
                let content = String(data: result.data, encoding: .utf8)
                #expect(content?.contains("SECTION") == true)
            }
        }
    }
    
    // MARK: - Validation Regressions
    
    @Test("REGRESSION: Validation bypassed for invalid input")
    func regressionValidationBypassed() async throws {
        // Issue: Invalid input sometimes bypassed validation checks
        // Fixed: Comprehensive validation at all entry points
        let invalidPanels = [
            FlattenedPanelDTO(
                points2D: [], // Invalid: empty points
                edges: [],
                color: .red,
                scaleUnitsPerMeter: 0 // Invalid: zero scale
            ),
            FlattenedPanelDTO(
                points2D: [CGPoint(x: 0, y: 0), CGPoint(x: 1, y: 1)], // Invalid: only 2 points
                edges: [],
                color: .blue,
                scaleUnitsPerMeter: -500 // Invalid: negative scale
            )
        ]
        
        // Validation should catch all issues
        for format in [ExportFormat.pdf, .svg, .dxf] {
            let validationResult = exportService.validateForExport(invalidPanels, format: format)
            #expect(!validationResult.isValid)
            #expect(!validationResult.errors.isEmpty)
        }
        
        // Export should fail with proper error
        let options = TestDataFactory.createTestExportOptions()
        await #expect(throws: CoverCraftError.self) {
            _ = try await exportService.exportPatterns(invalidPanels, format: .pdf, options: options)
        }
    }
    
    // MARK: - Boundary Condition Regressions
    
    @Test("REGRESSION: Zero-area panels causing division errors")
    func regressionZeroAreaPanelsDivisionErrors() async throws {
        // Issue: Panels with zero area caused division by zero in area calculations
        // Fixed: Added area validation and graceful handling
        let zeroAreaPanel = FlattenedPanelDTO(
            points2D: [
                CGPoint(x: 0, y: 0),
                CGPoint(x: 1, y: 0),
                CGPoint(x: 0, y: 0) // Same as first point - creates zero area
            ],
            edges: [
                EdgeDTO(startIndex: 0, endIndex: 1, type: .cutLine),
                EdgeDTO(startIndex: 1, endIndex: 2, type: .cutLine),
                EdgeDTO(startIndex: 2, endIndex: 0, type: .cutLine)
            ],
            color: .red,
            scaleUnitsPerMeter: 1000
        )
        
        // Should handle zero area gracefully
        #expect(zeroAreaPanel.area2D == 0)
        
        // Validation should catch this
        let validationResult = exportService.validateForExport([zeroAreaPanel], format: .pdf)
        // Either valid (if we handle zero area) or invalid with clear error
        if !validationResult.isValid {
            #expect(!validationResult.errors.isEmpty)
        }
    }
    
    @Test("REGRESSION: Maximum integer index overflow")
    func regressionMaximumIntegerIndexOverflow() async throws {
        // Issue: Very large vertex indices caused integer overflow
        // Fixed: Added bounds checking for indices
        let overflowMesh = MeshDTO(
            vertices: [
                SIMD3<Float>(0, 0, 0),
                SIMD3<Float>(1, 0, 0),
                SIMD3<Float>(0, 1, 0)
            ],
            triangleIndices: [0, 1, Int.max] // Overflow index
        )
        
        // Should catch overflow and reject
        await #expect(throws: CoverCraftError.self) {
            _ = try await segmentationService.segmentMesh(overflowMesh, targetPanelCount: 1)
        }
    }
    
    // MARK: - Platform-Specific Regressions
    
    @Test("REGRESSION: Floating point precision differences")
    func regressionFloatingPointPrecisionDifferences() async throws {
        // Issue: Different floating point precision on different platforms caused inconsistent results
        // Fixed: Normalized precision and added tolerance-based comparisons
        let mesh = TestDataFactory.createCubeMesh()
        
        // Run same operation multiple times - should be consistent
        var allResults: [[PanelDTO]] = []
        
        for _ in 0..<3 {
            let panels = try await segmentationService.segmentMesh(mesh, targetPanelCount: 6)
            allResults.append(panels)
        }
        
        // Results should be consistent (within floating point tolerance)
        let firstResult = allResults[0]
        for result in allResults {
            #expect(result.count == firstResult.count)
            
            // Panel counts and basic properties should be identical
            for (index, panel) in result.enumerated() {
                let firstPanel = firstResult[index]
                #expect(panel.vertexIndices.count == firstPanel.vertexIndices.count)
                #expect(panel.triangleIndices.count == firstPanel.triangleIndices.count)
            }
        }
    }
    
    // MARK: - Resource Management Regressions
    
    @Test("REGRESSION: File handle leaks in export operations")
    func regressionFileHandleLeaksInExport() async throws {
        // Issue: Export operations leaked file handles, causing system resource exhaustion
        // Fixed: Proper resource management with defer blocks and cleanup
        let panels = TestDataFactory.createTestFlattenedPanels(count: 2)
        let options = TestDataFactory.createTestExportOptions()
        
        // Perform many export operations - should not leak resources
        for _ in 0..<20 {
            let result = try await exportService.exportPatterns(panels, format: .pdf, options: options)
            #expect(!result.data.isEmpty)
            
            // Small delay to allow resource cleanup
            try await Task.sleep(nanoseconds: 1_000_000) // 1ms
        }
        
        // If we complete without system resource errors, leak is prevented
        #expect(true)
    }
    
    // MARK: - Error Handling Regressions
    
    @Test("REGRESSION: Cascading errors from invalid calibration")
    func regressionCascadingErrorsFromInvalidCalibration() async throws {
        // Issue: Invalid calibration caused cascading errors throughout the pipeline
        // Fixed: Isolated error handling and proper error boundaries
        let invalidCalibration = TestDataFactory.EdgeCases.incompleteCalibration()
        #expect(!calibrationService.validateCalibration(invalidCalibration))
        
        // Rest of pipeline should still work independently
        let mesh = TestDataFactory.createCubeMesh()
        let panels = try await segmentationService.segmentMesh(mesh, targetPanelCount: 6)
        let flattenedPanels = try await flatteningService.flattenPanels(panels, from: mesh)
        
        #expect(panels.count > 0)
        #expect(flattenedPanels.count > 0)
        
        // Export should work regardless of calibration state
        let options = TestDataFactory.createTestExportOptions()
        let result = try await exportService.exportPatterns(flattenedPanels, format: .svg, options: options)
        #expect(!result.data.isEmpty)
    }
    
    @Test("REGRESSION: Error messages not localized or informative")
    func regressionErrorMessagesNotInformative() async throws {
        // Issue: Error messages were generic and not helpful for debugging
        // Fixed: Specific, actionable error messages
        let emptyMesh = TestDataFactory.EdgeCases.emptyMesh()
        
        do {
            _ = try await segmentationService.segmentMesh(emptyMesh, targetPanelCount: 5)
            #expect(Bool(false), "Should have thrown an error for empty mesh")
        } catch let error as CoverCraftError {
            let errorMessage = error.localizedDescription
            
            // Error should be specific and informative
            #expect(!errorMessage.isEmpty)
            #expect(errorMessage.count > 10) // Not just generic "Error"
            #expect(errorMessage.lowercased().contains("mesh") || 
                   errorMessage.lowercased().contains("empty") ||
                   errorMessage.lowercased().contains("invalid"))
        } catch {
            #expect(Bool(false), "Should throw CoverCraftError, not generic error")
        }
    }
    
    // MARK: - Integration Test Summary
    
    @Test("REGRESSION: Overall system stability after all fixes")
    func regressionOverallSystemStability() async throws {
        // Final integration test to ensure all regression fixes work together
        let mesh = TestDataFactory.createComplexMesh(complexity: 2)
        let calibration = TestDataFactory.createTestCalibration(isComplete: true)
        
        // Complete workflow should be stable
        let (result, totalTime) = try await AsyncTestHelpers.measureAsync {
            #expect(calibrationService.validateCalibration(calibration))
            
            let panels = try await segmentationService.segmentMesh(mesh, targetPanelCount: 8)
            let flattenedPanels = try await flatteningService.flattenPanels(panels, from: mesh)
            let optimizedPanels = try await flatteningService.optimizeForCutting(flattenedPanels)
            
            let options = TestDataFactory.createTestExportOptions()
            return try await exportService.exportPatterns(optimizedPanels, format: .pdf, options: options)
        }
        
        // Should complete successfully
        #expect(!result.data.isEmpty)
        #expect(result.format == .pdf)
        
        // Should complete within reasonable time (no performance regressions)
        #expect(totalTime < 30.0)
        
        // Data should be valid and consistent
        #expect(result.metadata["panelCount"] != nil)
        #expect(!result.filename.isEmpty)
        
        print("Regression test: Complete workflow in \(totalTime)s - All fixes stable")
    }
}