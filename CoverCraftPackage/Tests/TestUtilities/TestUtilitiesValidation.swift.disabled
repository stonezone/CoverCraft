// Version: 1.0.0
// CoverCraft Test Utilities - Validation Tests
// 
// TDD-compliant validation tests for all test utilities
// Ensures all mock services and test data factories work correctly

import Testing
import Foundation
import CoverCraftCore
import CoverCraftDTO

/// Validation tests for test utilities
/// 
/// These tests ensure all mock services and test data factories
/// are working correctly and provide the expected TDD-compliant behavior.
struct TestUtilitiesValidation {
    
    // MARK: - TestDataFactory Validation Tests
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("TestDataFactory creates valid test mesh")
    func testDataFactoryCreatesValidMesh() async throws {
        let mesh = TestDataFactory.createTestMesh()
        
        #expect(mesh.isValid)
        #expect(mesh.vertices.count == 8) // Cube has 8 vertices
        #expect(mesh.triangleCount == 12) // Cube has 12 triangles
        #expect(mesh.triangleIndices.count == 36) // 12 triangles * 3 indices
    }
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("TestDataFactory creates valid test panels")
    func testDataFactoryCreatesValidPanels() async throws {
        let panels = TestDataFactory.createTestPanels(count: 5)
        
        #expect(panels.count == 5)
        
        for panel in panels {
            #expect(panel.isValid)
            #expect(!panel.vertexIndices.isEmpty)
            #expect(!panel.triangleIndices.isEmpty)
            #expect(panel.triangleIndices.count % 3 == 0)
        }
    }
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("TestDataFactory creates valid flattened panels")
    func testDataFactoryCreatesFlattenedPanels() async throws {
        let flattenedPanels = TestDataFactory.createTestFlattenedPanels(count: 3)
        
        #expect(flattenedPanels.count == 3)
        
        for panel in flattenedPanels {
            #expect(panel.isValid)
            #expect(panel.points2D.count >= 3)
            #expect(!panel.edges.isEmpty)
            #expect(panel.scaleUnitsPerMeter > 0)
            #expect(panel.area > 0)
        }
    }
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("TestDataFactory creates valid calibration")
    func testDataFactoryCreatesCalibration() async throws {
        let calibration = TestDataFactory.createTestCalibration()
        
        #expect(calibration.isComplete)
        #expect(calibration.scaleFactor > 0)
        #expect(calibration.meshDistance > 0)
        #expect(calibration.realWorldDistance > 0)
    }
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("TestDataFactory creates export data")
    func testDataFactoryCreatesExportData() async throws {
        let exportResult = TestDataFactory.createTestExportResult()
        let exportOptions = TestDataFactory.createTestExportOptions()
        
        #expect(!exportResult.data.isEmpty)
        #expect(!exportResult.filename.isEmpty)
        #expect(exportResult.format == .pdf)
        
        #expect(exportOptions.paperSize == .a4)
        #expect(exportOptions.seamAllowanceWidth > 0)
    }
    
    // MARK: - MockARScanningService Validation Tests
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("MockARScanningService implements protocol correctly")
    func mockARScanningServiceImplementsProtocol() async throws {
        let mockService = MockARScanningService.withTestMesh()
        
        // Test AR availability
        let isAvailable = mockService.isARAvailable()
        #expect(isAvailable == true)
        
        // Test scanning lifecycle
        try await mockService.startScanning()
        #expect(mockService.verifyStartScanningCalledOnce())
        
        let mesh = await mockService.getCurrentMesh()
        #expect(mesh != nil)
        #expect(mesh?.isValid == true)
        
        await mockService.stopScanning()
        #expect(mockService.verifyStopScanningCalledOnce())
        
        // Verify call tracking
        #expect(mockService.getTotalCallCount() > 0)
        #expect(!mockService.methodCallHistory.isEmpty)
    }
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("MockARScanningService handles errors correctly")
    func mockARScanningServiceHandlesErrors() async throws {
        let mockService = MockARScanningService.withScanningError()
        
        do {
            try await mockService.startScanning()
            #expect(Bool(false), "Expected scanning error")
        } catch {
            // Expected error - test passes
            #expect(error is ARScanningError)
        }
    }
    
    // MARK: - MockMeshSegmentationService Validation Tests
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("MockMeshSegmentationService segments mesh correctly")
    func mockMeshSegmentationServiceSegmentsMesh() async throws {
        let mockService = MockMeshSegmentationService.withTestPanels(count: 5)
        let testMesh = TestDataFactory.createTestMesh()
        
        let panels = try await mockService.segmentMesh(testMesh, targetPanelCount: 5)
        
        #expect(panels.count <= 5)
        #expect(mockService.verifySegmentMeshCalled(withMeshId: testMesh.id, targetPanelCount: 5))
        
        for panel in panels {
            #expect(panel.isValid)
        }
    }
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("MockMeshSegmentationService previews segmentation")
    func mockMeshSegmentationServicePreviewsSegmentation() async throws {
        let mockService = MockMeshSegmentationService.withDynamicResults()
        let testMesh = TestDataFactory.createTestMesh()
        
        let previewPanels = try await mockService.previewSegmentation(testMesh, resolution: .medium)
        
        #expect(!previewPanels.isEmpty)
        #expect(mockService.verifyPreviewSegmentationCalled(withMeshId: testMesh.id, resolution: .medium))
    }
    
    // MARK: - MockPatternFlatteningService Validation Tests
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("MockPatternFlatteningService flattens panels")
    func mockPatternFlatteningServiceFlattens() async throws {
        let mockService = MockPatternFlatteningService.withTestFlattenedPanels(count: 3)
        let testMesh = TestDataFactory.createTestMesh()
        let testPanels = TestDataFactory.createTestPanels(count: 3, from: testMesh)
        
        let flattenedPanels = try await mockService.flattenPanels(testPanels, from: testMesh)
        
        #expect(flattenedPanels.count == 3)
        #expect(mockService.verifyFlattenPanelsCalled(withPanelCount: 3, meshId: testMesh.id))
        
        for panel in flattenedPanels {
            #expect(panel.isValid)
        }
    }
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("MockPatternFlatteningService optimizes for cutting")
    func mockPatternFlatteningServiceOptimizes() async throws {
        let mockService = MockPatternFlatteningService()
        let testFlattenedPanels = TestDataFactory.createTestFlattenedPanels(count: 3)
        
        let optimizedPanels = try await mockService.optimizeForCutting(testFlattenedPanels)
        
        #expect(optimizedPanels.count == testFlattenedPanels.count)
        #expect(mockService.verifyOptimizeForCuttingCalled(withPanelCount: 3))
        #expect(mockService.verifyCompletedSuccessfully())
    }
    
    // MARK: - MockPatternExportService Validation Tests
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("MockPatternExportService exports patterns")
    func mockPatternExportServiceExports() async throws {
        let mockService = MockPatternExportService.withSuccessfulExport()
        let testPanels = TestDataFactory.createTestFlattenedPanels(count: 2)
        let exportOptions = TestDataFactory.createTestExportOptions()
        
        let exportResult = try await mockService.exportPatterns(testPanels, format: .pdf, options: exportOptions)
        
        #expect(!exportResult.data.isEmpty)
        #expect(exportResult.format == .pdf)
        #expect(mockService.verifyExportPatternsCalled(withPanelCount: 2, format: .pdf))
        #expect(mockService.verifyExportOptions(exportOptions))
    }
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("MockPatternExportService validates export")
    func mockPatternExportServiceValidates() async throws {
        let mockService = MockPatternExportService()
        let testPanels = TestDataFactory.createTestFlattenedPanels(count: 2)
        
        let validationResult = mockService.validateForExport(testPanels, format: .svg)
        
        #expect(validationResult.isValid)
        #expect(mockService.verifyValidateForExportCalled(withPanelCount: 2, format: .svg))
    }
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("MockPatternExportService returns supported formats")
    func mockPatternExportServiceSupportedFormats() async throws {
        let mockService = MockPatternExportService()
        
        let formats = mockService.getSupportedFormats()
        
        #expect(!formats.isEmpty)
        #expect(formats.contains(.pdf))
        #expect(formats.contains(.svg))
    }
    
    // MARK: - AsyncTestHelpers Validation Tests
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("AsyncTestHelpers handles timeouts correctly")
    func asyncTestHelpersHandlesTimeouts() async throws {
        do {
            _ = try await AsyncTestHelpers.withTimeout(0.1) {
                try await Task.sleep(nanoseconds: 200_000_000) // 0.2 seconds
                return "Should timeout"
            }
            #expect(Bool(false), "Expected timeout error")
        } catch AsyncTestError.timeout {
            // Expected timeout - test passes
        } catch {
            #expect(Bool(false), "Expected timeout error, got: \(error)")
        }
    }
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("AsyncTestHelpers measures execution time")
    func asyncTestHelpersMeasuresTime() async throws {
        let delay: TimeInterval = 0.1
        
        let (result, executionTime) = try await AsyncTestHelpers.measureAsync {
            try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
            return "test result"
        }
        
        #expect(result == "test result")
        #expect(executionTime >= delay)
        #expect(executionTime < delay + 0.05) // Allow some tolerance
    }
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("AsyncTestHelpers executes concurrent operations")
    func asyncTestHelpersExecutesConcurrently() async throws {
        let operations: [@Sendable () async throws -> Int] = [
            { try await Task.sleep(nanoseconds: 10_000_000); return 1 },
            { try await Task.sleep(nanoseconds: 20_000_000); return 2 },
            { try await Task.sleep(nanoseconds: 15_000_000); return 3 }
        ]
        
        let results = try await AsyncTestHelpers.executeConcurrently(operations: operations)
        
        #expect(results.count == 3)
        #expect(results[0] == 1)
        #expect(results[1] == 2)
        #expect(results[2] == 3)
    }
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("AsyncTestHelpers validates async conditions")
    func asyncTestHelpersValidatesConditions() async throws {
        actor Counter {
            var value = 0
            
            func increment() -> Int {
                value += 1
                return value
            }
            
            func getValue() -> Int {
                return value
            }
        }
        
        let counter = Counter()
        
        try await AsyncTestHelpers.waitForCondition(
            condition: {
                let value = await counter.increment()
                return value >= 3
            },
            timeout: 1.0,
            pollInterval: 0.01
        )
        
        let finalValue = await counter.getValue()
        #expect(finalValue >= 3)
    }
    
    // MARK: - Integration Test
    
    @available(iOS 18.0, macOS 15.0, *)
    @Test("All test utilities work together in integration scenario")
    func testUtilitiesIntegration() async throws {
        // Create complete test data set
        let testDataset = TestDataFactory.createCompleteTestDataset()
        
        #expect(testDataset["mesh"] is MeshDTO)
        #expect(testDataset["panels"] is [PanelDTO])
        #expect(testDataset["flattenedPanels"] is [FlattenedPanelDTO])
        #expect(testDataset["calibration"] is CalibrationDTO)
        
        // Test all mock services with the data
        let arService = MockARScanningService.withTestMesh()
        let segmentationService = MockMeshSegmentationService.withDynamicResults()
        let flatteningService = MockPatternFlatteningService()
        let exportService = MockPatternExportService.withSuccessfulExport()
        
        // Simulate complete workflow with async testing
        let mesh = await arService.getCurrentMesh()
        #expect(mesh != nil)
        
        let panels = try await segmentationService.segmentMesh(mesh!, targetPanelCount: 5)
        #expect(!panels.isEmpty)
        
        let flattenedPanels = try await flatteningService.flattenPanels(panels, from: mesh!)
        #expect(flattenedPanels.count == panels.count)
        
        let exportOptions = TestDataFactory.createTestExportOptions()
        let exportResult = try await exportService.exportPatterns(flattenedPanels, format: .pdf, options: exportOptions)
        #expect(!exportResult.data.isEmpty)
        
        // Verify all services were called correctly
        #expect(arService.getCurrentMeshCallCount == 1)
        #expect(segmentationService.segmentMeshCallCount == 1)
        #expect(flatteningService.flattenPanelsCallCount == 1)
        #expect(exportService.exportPatternsCallCount == 1)
    }
}