// Version: 1.0.0
// CoverCraft Contract Tests - DTO Contract Tests

import Testing
import SnapshotTesting
import Foundation
import TestUtilities
import simd
@testable import CoverCraftDTO
@testable import CoverCraftCore

/// Contract tests to ensure DTO serialization remains stable across versions
/// These tests protect against breaking changes in the API
/// Contract tests to ensure DTO serialization remains stable across versions
/// These tests protect against breaking changes in the API
@Suite("DTO Contract Tests")
struct DTOContractTests {
    
    // MARK: - MeshDTO Contract Tests
    
    @Test("MeshDTO serialization contract")
    func meshDTOSerializationContract() throws {
        let mesh = TestDataFactory.createCubeMesh()
        
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        encoder.dateEncodingStrategy = .iso8601
        
        let jsonData = try encoder.encode(mesh)
        let jsonString = String(data: jsonData, encoding: .utf8)!
        
        // Ensure we can deserialize back
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        let deserializedMesh = try decoder.decode(MeshDTO.self, from: jsonData)
        
        #expect(deserializedMesh.vertices.count == mesh.vertices.count)
        #expect(deserializedMesh.triangleIndices == mesh.triangleIndices)
        #expect(deserializedMesh.isValid == mesh.isValid)
    }
    
    @Test("MeshDTO backward compatibility")
    func meshDTOBackwardCompatibility() throws {
        // Test JSON from a previous version to ensure we can still deserialize
        let legacyJSON = """
        {
          "vertices" : [
            [ 0.0, 0.0, 0.0 ],
            [ 1.0, 0.0, 0.0 ],
            [ 0.5, 1.0, 0.0 ]
          ],
          "triangleIndices" : [ 0, 1, 2 ]
        }
        """
        
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        
        let mesh = try decoder.decode(MeshDTO.self, from: legacyJSON.data(using: .utf8)!)
        
        #expect(mesh.vertices.count == 3)
        #expect(mesh.triangleIndices == [0, 1, 2])
        #expect(mesh.isValid)
    }
    
    @Test("MeshDTO validation contract")
    func meshDTOValidationContract() throws {
        // Valid mesh
        let validMesh = TestDataFactory.createTriangleMesh()
        #expect(validMesh.isValid)
        #expect(validMesh.triangleCount == 1)
        
        // Invalid mesh - empty
        let emptyMesh = TestDataFactory.EdgeCases.emptyMesh()
        #expect(!emptyMesh.isValid)
        #expect(emptyMesh.triangleCount == 0)
        
        // Invalid mesh - bad indices
        let invalidMesh = TestDataFactory.createInvalidMesh()
        #expect(!invalidMesh.isValid)
    }
    
    // MARK: - PanelDTO Contract Tests
    
    @Test("PanelDTO serialization contract")
    func panelDTOSerializationContract() throws {
        let panel = TestDataFactory.createTestPanel(color: .red, triangleCount: 2)
        
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        encoder.dateEncodingStrategy = .iso8601
        
        let jsonData = try encoder.encode(panel)
        let jsonString = String(data: jsonData, encoding: .utf8)!
        
        // Verify round-trip serialization
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        let deserializedPanel = try decoder.decode(PanelDTO.self, from: jsonData)
        
        #expect(deserializedPanel.vertexIndices == panel.vertexIndices)
        #expect(deserializedPanel.triangleIndices == panel.triangleIndices)
        #expect(deserializedPanel.color == panel.color)
    }
    
    @Test("ColorDTO serialization contract")
    func colorDTOSerializationContract() throws {
        let testColors: [ColorDTO] = [.red, .green, .blue, .yellow, .orange, .purple, .cyan, .magenta]
        
        for color in testColors {
            let encoder = JSONEncoder()
            encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
            
            let jsonData = try encoder.encode(color)
            
            let decoder = JSONDecoder()
            let deserializedColor = try decoder.decode(ColorDTO.self, from: jsonData)
            
            #expect(deserializedColor == color)
            #expect(deserializedColor.red >= 0.0 && deserializedColor.red <= 1.0)
            #expect(deserializedColor.green >= 0.0 && deserializedColor.green <= 1.0)
            #expect(deserializedColor.blue >= 0.0 && deserializedColor.blue <= 1.0)
            #expect(deserializedColor.alpha >= 0.0 && deserializedColor.alpha <= 1.0)
        }
    }
    
    // MARK: - FlattenedPanelDTO Contract Tests
    
    @Test("FlattenedPanelDTO serialization contract")
    func flattenedPanelDTOSerializationContract() throws {
        let flattenedPanel = TestDataFactory.createTestFlattenedPanel()
        
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        encoder.dateEncodingStrategy = .iso8601
        
        let jsonData = try encoder.encode(flattenedPanel)
        
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        let deserializedPanel = try decoder.decode(FlattenedPanelDTO.self, from: jsonData)
        
        #expect(deserializedPanel.points2D.count == flattenedPanel.points2D.count)
        #expect(deserializedPanel.edges.count == flattenedPanel.edges.count)
        #expect(deserializedPanel.color == flattenedPanel.color)
        #expect(deserializedPanel.scaleUnitsPerMeter == flattenedPanel.scaleUnitsPerMeter)
    }
    
    @Test("FlattenedPanelDTO computed properties contract")
    func flattenedPanelDTOComputedPropertiesContract() throws {
        let panel = TestDataFactory.createTestFlattenedPanel()
        
        // Test computed properties are stable
        #expect(panel.isValid)
        #expect(panel.boundingBox.width > 0)
        #expect(panel.boundingBox.height > 0)
        #expect(panel.area > 0)

        // Test edge case - tiny panel
        let tinyPanel = TestDataFactory.EdgeCases.tinyFlattenedPanel()
        #expect(tinyPanel.area > 0) // Even tiny panels should have positive area
        
        // Test complex panel
        let complexPanel = TestDataFactory.createComplexFlattenedPanel()
        #expect(complexPanel.isValid)
        #expect(complexPanel.edges.count > 4) // L-shaped should have more edges
    }
    
    @Test("EdgeDTO and EdgeType contract")
    func edgeDTOContract() throws {
        let edge = EdgeDTO(
            startIndex: 0,
            endIndex: 1,
            type: .cutLine
        )
        
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        
        let jsonData = try encoder.encode(edge)
        
        let decoder = JSONDecoder()
        let deserializedEdge = try decoder.decode(EdgeDTO.self, from: jsonData)
        
        #expect(deserializedEdge == edge)
        
        // Test all EdgeType cases for stability
        let allEdgeTypes = EdgeType.allCases
        #expect(allEdgeTypes.count == 4)
        #expect(allEdgeTypes.contains(.cutLine))
        #expect(allEdgeTypes.contains(.foldLine))
        #expect(allEdgeTypes.contains(.seamAllowance))
        #expect(allEdgeTypes.contains(.registrationMark))
        
        // Test EdgeType raw values (contract stability)
        #expect(EdgeType.cutLine.rawValue == "cut")
        #expect(EdgeType.foldLine.rawValue == "fold")
        #expect(EdgeType.seamAllowance.rawValue == "seam")
        #expect(EdgeType.registrationMark.rawValue == "registration")
    }
    
    // MARK: - CalibrationDTO Contract Tests
    
    @Test("CalibrationDTO serialization contract")
    func calibrationDTOSerializationContract() throws {
        let completeCalibration = TestDataFactory.createTestCalibration(isComplete: true)
        let incompleteCalibration = TestDataFactory.createTestCalibration(isComplete: false)
        
        for calibration in [completeCalibration, incompleteCalibration] {
            let encoder = JSONEncoder()
            encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
            encoder.dateEncodingStrategy = .iso8601
            
            let jsonData = try encoder.encode(calibration)
            
            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601
            let deserializedCalibration = try decoder.decode(CalibrationDTO.self, from: jsonData)
            
            #expect(deserializedCalibration.firstPoint == calibration.firstPoint)
            #expect(deserializedCalibration.secondPoint == calibration.secondPoint)
            #expect(deserializedCalibration.realWorldDistance == calibration.realWorldDistance)
            #expect(deserializedCalibration.isComplete == calibration.isComplete)
        }
    }
    
    @Test("CalibrationDTO validation contract")
    func calibrationDTOValidationContract() throws {
        // Complete calibration
        let completeCalibration = TestDataFactory.createTestCalibration(isComplete: true)
        #expect(completeCalibration.isComplete)
        
        // Incomplete calibration
        let incompleteCalibration = TestDataFactory.createTestCalibration(isComplete: false)
        #expect(!incompleteCalibration.isComplete)
        
        // Edge case calibration
        let edgeCaseCalibration = TestDataFactory.EdgeCases.incompleteCalibration()
        #expect(!edgeCaseCalibration.isComplete)
        
        // Empty calibration
        let emptyCalibration = CalibrationDTO.empty()
        #expect(!emptyCalibration.isComplete)
        #expect(emptyCalibration.isEmpty)
    }
    
    // MARK: - Export Related DTO Contract Tests
    
    @Test("ExportOptions serialization contract")
    func exportOptionsSerializationContract() throws {
        let options = TestDataFactory.createTestExportOptions(format: .pdf, paperSize: .a4)
        
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        
        let jsonData = try encoder.encode(options)
        
        let decoder = JSONDecoder()
        let deserializedOptions = try decoder.decode(ExportOptions.self, from: jsonData)
        
        #expect(deserializedOptions == options)
        #expect(deserializedOptions.paperSize == .a4)
        #expect(deserializedOptions.scale > 0)
    }
    
    @Test("ExportResult serialization contract")
    func exportResultSerializationContract() throws {
        let result = TestDataFactory.createTestExportResult(format: .svg, panelCount: 5)
        
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        
        let jsonData = try encoder.encode(result)
        
        let decoder = JSONDecoder()
        let deserializedResult = try decoder.decode(ExportResult.self, from: jsonData)
        
        #expect(deserializedResult.format == result.format)
        #expect(deserializedResult.filename == result.filename)
        #expect(deserializedResult.metadata == result.metadata)
        #expect(!deserializedResult.data.isEmpty)
    }
    
    @Test("ExportValidationResult contract")
    func exportValidationResultContract() throws {
        let validResult = TestDataFactory.createTestValidationResult(isValid: true)
        let invalidResult = TestDataFactory.createTestValidationResult(isValid: false, errorCount: 2, warningCount: 1)

        // ExportValidationResult is a simple struct defined in CoverCraftCore
        #expect(validResult.isValid == true)
        #expect(validResult.errors.isEmpty)
        #expect(validResult.warnings.isEmpty)

        #expect(invalidResult.isValid == false)
        #expect(invalidResult.errors.count == 2)
        #expect(invalidResult.warnings.count == 1)
    }
    
    // MARK: - Enum Contract Tests
    
    @Test("SegmentationResolution contract")
    func segmentationResolutionContract() throws {
        let allResolutions = SegmentationResolution.allCases
        
        #expect(allResolutions.count == 3)
        #expect(allResolutions.contains(.low))
        #expect(allResolutions.contains(.medium))
        #expect(allResolutions.contains(.high))
        
        // Test raw values for stability
        #expect(SegmentationResolution.low.rawValue == "Low (5 panels)")
        #expect(SegmentationResolution.medium.rawValue == "Medium (6-10 panels)")
        #expect(SegmentationResolution.high.rawValue == "High (up to 15 panels)")
        
        // Test target panel counts
        #expect(SegmentationResolution.low.targetPanelCount == 5)
        #expect(SegmentationResolution.medium.targetPanelCount == 8)
        #expect(SegmentationResolution.high.targetPanelCount == 15)
    }
    
    @Test("ExportFormat contract")
    func exportFormatContract() throws {
        let allFormats = ExportFormat.allCases
        
        #expect(allFormats.count == 5)
        #expect(allFormats.contains(.pdf))
        #expect(allFormats.contains(.svg))
        #expect(allFormats.contains(.png))
        #expect(allFormats.contains(.gif))
        #expect(allFormats.contains(.dxf))
        
        // Test raw values and file extensions
        for format in allFormats {
            #expect(!format.rawValue.isEmpty)
            #expect(!format.fileExtension.isEmpty)
            #expect(format.fileExtension == format.rawValue.lowercased())
        }
    }
    
    @Test("PaperSize contract")
    func paperSizeContract() throws {
        let allSizes = PaperSize.allCases
        
        #expect(allSizes.count == 5)
        #expect(allSizes.contains(.a4))
        #expect(allSizes.contains(.a3))
        #expect(allSizes.contains(.letter))
        #expect(allSizes.contains(.legal))
        #expect(allSizes.contains(.tabloid))
        
        // Test dimensions are reasonable
        for size in allSizes {
            let dimensions = size.dimensionsInPoints
            #expect(dimensions.width > 0)
            #expect(dimensions.height > 0)
            #expect(dimensions.width < 2000) // Reasonable upper bound
            #expect(dimensions.height < 2000)
        }
        
        // Test specific dimensions for key sizes
        #expect(PaperSize.a4.dimensionsInPoints.width == 595)
        #expect(PaperSize.a4.dimensionsInPoints.height == 842)
        #expect(PaperSize.letter.dimensionsInPoints.width == 612)
        #expect(PaperSize.letter.dimensionsInPoints.height == 792)
    }
    
    // MARK: - Cross-DTO Integration Tests
    
    @Test("DTO ID uniqueness contract")
    func dtoIDUniquenessContract() {
        let mesh = TestDataFactory.createCubeMesh()
        let panels = TestDataFactory.createTestPanels(count: 5, from: mesh)
        let flattenedPanels = TestDataFactory.createTestFlattenedPanels(count: 3)
        let calibration = TestDataFactory.createTestCalibration()
        
        // Collect all IDs
        var allIds: [UUID] = [mesh.id, calibration.id]
        allIds.append(contentsOf: panels.map { $0.id })
        allIds.append(contentsOf: flattenedPanels.map { $0.id })
        
        // All IDs should be unique
        let uniqueIds = Set(allIds)
        #expect(uniqueIds.count == allIds.count)
    }
    
    @Test("DTO timestamp consistency contract")
    func dtoTimestampConsistencyContract() {
        let beforeCreation = Date()
        
        let mesh = TestDataFactory.createCubeMesh()
        let panel = TestDataFactory.createTestPanel()
        let flattenedPanel = TestDataFactory.createTestFlattenedPanel()
        let calibration = TestDataFactory.createTestCalibration()
        
        let afterCreation = Date()

        // All creation timestamps should be within the test timeframe
        #expect(mesh.createdAt >= beforeCreation)
        #expect(mesh.createdAt <= afterCreation)
        #expect(panel.createdAt >= beforeCreation)
        #expect(panel.createdAt <= afterCreation)
        #expect(flattenedPanel.createdAt >= beforeCreation)
        #expect(flattenedPanel.createdAt <= afterCreation)
        #expect(calibration.createdAt >= beforeCreation)
        #expect(calibration.createdAt <= afterCreation)
    }
    
    @Test("DTO relationship integrity contract")
    func dtoRelationshipIntegrityContract() throws {
        let mesh = TestDataFactory.createCubeMesh()
        let panels = TestDataFactory.createTestPanels(count: 3, from: mesh)
        
        // All panel vertex indices should reference valid mesh vertices
        for panel in panels {
            for vertexIndex in panel.vertexIndices {
                #expect(vertexIndex >= 0)
                #expect(vertexIndex < mesh.vertices.count)
            }
            
            for triangleIndex in panel.triangleIndices {
                #expect(triangleIndex >= 0)
                #expect(triangleIndex < mesh.vertices.count)
            }
        }
    }
    
    // MARK: - Stress Testing Contract
    
    @Test("Large data serialization contract")
    func largeDataSerializationContract() throws {
        let largeMesh = TestDataFactory.createComplexMesh(complexity: 4)
        let manyPanels = TestDataFactory.createTestPanels(count: 20, from: largeMesh)
        let manyFlattenedPanels = TestDataFactory.createTestFlattenedPanels(count: 15)
        
        // Should handle large datasets
        let encoder = JSONEncoder()
        
        let meshData = try encoder.encode(largeMesh)
        #expect(meshData.count > 1000) // Should be substantial
        
        let panelsData = try encoder.encode(manyPanels)
        #expect(panelsData.count > 500)
        
        let flatPanelsData = try encoder.encode(manyFlattenedPanels)
        #expect(flatPanelsData.count > 1000)
        
        // Should deserialize correctly
        let decoder = JSONDecoder()
        let deserializedMesh = try decoder.decode(MeshDTO.self, from: meshData)
        #expect(deserializedMesh.vertices.count == largeMesh.vertices.count)
        
        let deserializedPanels = try decoder.decode([PanelDTO].self, from: panelsData)
        #expect(deserializedPanels.count == manyPanels.count)
    }
    
    @Test("Edge case serialization contract")
    func edgeCaseSerializationContract() throws {
        let edgeCases = [
            TestDataFactory.EdgeCases.emptyMesh(),
            TestDataFactory.EdgeCases.minimalMesh(),
            TestDataFactory.createInvalidMesh()
        ]
        
        let encoder = JSONEncoder()
        let decoder = JSONDecoder()
        
        for mesh in edgeCases {
            // Should serialize even invalid meshes
            let data = try encoder.encode(mesh)
            #expect(!data.isEmpty)
            
            // Should deserialize back to equivalent object
            let deserialized = try decoder.decode(MeshDTO.self, from: data)
            #expect(deserialized.vertices.count == mesh.vertices.count)
            #expect(deserialized.triangleIndices == mesh.triangleIndices)
            #expect(deserialized.isValid == mesh.isValid) // Validation state preserved
        }
    }
}
